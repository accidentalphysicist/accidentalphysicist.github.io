<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Teaching Canvas - Pro</title>
<style>
  body { margin: 0; background: #1e1e1e; font-family: sans-serif; color: white; overflow: hidden; }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0;
    background: #2b2b2b; padding: 8px; display: flex; gap: 8px; z-index: 10;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5); align-items: center;
  }
  button, input { padding: 6px 12px; cursor: pointer; border: none; border-radius: 4px; }
  button { background: #444; color: white; font-weight: bold; }
  button.active { background: #007bff; outline: 2px solid yellow; }
  #canvas-container { margin-top: 50px; height: calc(100vh - 50px); overflow: auto; background: #333; }
  canvas { background: white; display: block; margin: 20px auto; cursor: crosshair; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
  
  /* Floating text input styling */
  #textInput {
    position: absolute; display: none; background: transparent; border: 1px dashed #007bff;
    outline: none; padding: 0; margin: 0; font-family: sans-serif; line-height: 1;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button id="penBtn" class="active">Pen</button>
  <button id="eraserBtn">Eraser</button>
  <button id="lineBtn">Line</button>
  <button id="rectBtn">Rect</button>
  <button id="circleBtn">Circle</button>
  <button id="textBtn">Text</button>
  <div style="width:1px; height:25px; background:#555; margin:0 5px;"></div>
  <input type="color" id="colorPicker" value="#000000">
  <input type="range" id="sizePicker" min="1" max="50" value="3">
  <button id="clearBtn" style="margin-left:auto; background:#8b0000;">Clear All</button>
</div>

<div id="canvas-container">
  <canvas id="canvas" width="1200" height="2000"></canvas>
  <input type="text" id="textInput">
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });
const colorPicker = document.getElementById("colorPicker");
const sizePicker = document.getElementById("sizePicker");
const textInput = document.getElementById("textInput");

ctx.lineCap = "round";
ctx.lineJoin = "round";

let tool = "pen";
let drawing = false;
let startX, startY;
let snapshot;
const undoStack = [];

function saveState() {
  if (undoStack.length >= 50) undoStack.shift();
  undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
}

function undo() {
  if (undoStack.length > 1) {
    undoStack.pop();
    ctx.putImageData(undoStack[undoStack.length - 1], 0, 0);
  }
}

saveState();

// Tool handling
const buttons = document.querySelectorAll("#toolbar button");
buttons.forEach(btn => {
  btn.onclick = () => {
    if(btn.id === "clearBtn") {
        if(confirm("Clear everything?")) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveState();
        }
        return;
    }
    tool = btn.id.replace("Btn", "");
    buttons.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    textInput.style.display = "none"; // Hide text input if switching tools
  };
});

canvas.addEventListener("pointerdown", e => {
  if (tool === "text") {
    showTextInput(e);
    return;
  }
  
  drawing = true;
  startX = e.offsetX;
  startY = e.offsetY;
  snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.strokeStyle = colorPicker.value;
  ctx.fillStyle = colorPicker.value;
  ctx.lineWidth = sizePicker.value;
});

canvas.addEventListener("pointermove", e => {
  if (!drawing || tool === "text") return;

  if (tool !== "pen" && tool !== "eraser") {
    ctx.putImageData(snapshot, 0, 0);
  }

  if (tool === "pen") {
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
  } else if (tool === "eraser") {
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    ctx.globalCompositeOperation = "source-over";
  } else if (tool === "line") {
    ctx.beginPath(); ctx.moveTo(startX, startY);
    ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke();
  } else if (tool === "rect") {
    ctx.strokeRect(startX, startY, e.offsetX - startX, e.offsetY - startY);
  } else if (tool === "circle") {
    const r = Math.hypot(e.offsetX - startX, e.offsetY - startY);
    ctx.beginPath(); ctx.arc(startX, startY, r, 0, Math.PI * 2); ctx.stroke();
  }
});

canvas.addEventListener("pointerup", () => {
  if (drawing) {
    drawing = false;
    saveState();
  }
});

/* =========================
   TEXT TOOL LOGIC
========================= */
function showTextInput(e) {
  const fontSize = parseInt(sizePicker.value) + 15;
  textInput.style.display = "block";
  textInput.style.left = (e.pageX) + "px";
  textInput.style.top = (e.pageY - fontSize/2) + "px";
  textInput.style.color = colorPicker.value;
  textInput.style.fontSize = fontSize + "px";
  textInput.value = "";
  
  // Save coordinates for the canvas
  startX = e.offsetX;
  startY = e.offsetY;
  
  setTimeout(() => textInput.focus(), 10);
}

textInput.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    const fontSize = parseInt(sizePicker.value) + 15;
    ctx.fillStyle = colorPicker.value;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textBaseline = "middle";
    ctx.fillText(textInput.value, startX, startY);
    
    textInput.style.display = "none";
    saveState();
  } else if (e.key === "Escape") {
    textInput.style.display = "none";
  }
});

// Undo shortcut
document.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") { e.preventDefault(); undo(); }
});
</script>
</body>
</html>
