<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pro Teaching Canvas - Object Layering</title>
<style>
  body { margin: 0; background: #1e1e1e; font-family: sans-serif; color: white; overflow: hidden; }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0;
    background: #2b2b2b; padding: 8px; display: flex; gap: 8px; z-index: 100;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5); align-items: center;
  }
  button, input, select { padding: 6px 12px; cursor: pointer; border: none; border-radius: 4px; background: #444; color: white; font-weight: bold; }
  button.active { background: #007bff; outline: 2px solid yellow; }
  #canvas-container { margin-top: 60px; height: calc(100vh - 60px); overflow: auto; background: #333; position: relative; }
  canvas { background: white; display: block; margin: 20px auto; cursor: crosshair; touch-action: none; }
  #textInput { position: absolute; display: none; background: white; border: 1px solid #007bff; color: black; outline: none; z-index: 1000; }
  .group { display: flex; align-items: center; gap: 5px; border-right: 1px solid #555; padding-right: 10px; }
</style>
</head>
<body>

<div id="toolbar">
  <div class="group">
    <button id="penBtn" class="active">Pen</button>
    <button id="eraserBtn">Eraser</button>
    <button id="textBtn">Text</button>
    <button id="selectBtn">Select</button>
  </div>
  <div class="group">
    <select id="shapeSelect">
      <option value="none">Shapes...</option>
      <option value="line">Line</option>
      <option value="arrow">Arrow</option>
      <option value="rect">Rectangle</option>
      <option value="circle">Circle</option>
    </select>
  </div>
  <input type="color" id="colorPicker" value="#000000">
  <input type="range" id="sizePicker" min="1" max="50" value="3">
  <button id="exportBtn" style="background: #28a745;">Export PDF</button>
  <button id="clearBtn" style="background:#8b0000;">Clear</button>
</div>

<div id="canvas-container">
  <canvas id="canvas" width="1200" height="1500"></canvas>
  <input type="text" id="textInput">
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const colorPicker = document.getElementById("colorPicker");
const sizePicker = document.getElementById("sizePicker");
const shapeSelect = document.getElementById("shapeSelect");
const textInput = document.getElementById("textInput");

let tool = "pen";
let drawing = false;
let activeObj = null; 
let transformMode = null; 
let startX, startY, lastX, lastY;

// This holds the permanent pixel data (Pen/Eraser/Baked Objects)
let bgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

function saveToBackground() {
    bgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function bake() {
    if (activeObj) {
        // Draw the object permanently to the canvas
        activeObj.draw(ctx, false); 
        activeObj = null;
        saveToBackground();
        render();
    }
}

function render() {
    // 1. Clear everything
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 2. Put back the permanent background
    ctx.putImageData(bgData, 0, 0);
    // 3. Draw the active object on top (with UI if active)
    if (activeObj) {
        activeObj.draw(ctx, true);
    }
}

class CanvasObject {
    constructor(type, x, y, color, size, content = null) {
        this.type = type; this.x = x; this.y = y; this.w = 5; this.h = 5;
        this.color = color; this.size = size; this.content = content;
    }
    draw(tCtx, showUI) {
        tCtx.save();
        tCtx.strokeStyle = this.color;
        tCtx.fillStyle = this.color;
        tCtx.lineWidth = this.size;

        if (this.type === 'text') {
            tCtx.font = `${this.size + 15}px sans-serif`;
            tCtx.textBaseline = "top";
            tCtx.fillText(this.content, this.x, this.y);
            // Update bounds for text based on measurement
            let metrics = tCtx.measureText(this.content);
            this.w = metrics.width;
            this.h = this.size + 15;
        } else if (this.type === 'rect') {
            tCtx.strokeRect(this.x, this.y, this.w, this.h);
        } else if (this.type === 'circle') {
            tCtx.beginPath();
            tCtx.arc(this.x + this.w/2, this.y + this.h/2, Math.abs(this.w/2), 0, Math.PI*2);
            tCtx.stroke();
        } else if (this.type === 'line' || this.type === 'arrow') {
            tCtx.beginPath();
            tCtx.moveTo(this.x, this.y);
            tCtx.lineTo(this.x + this.w, this.y + this.h);
            if (this.type === 'arrow') drawArrowHead(tCtx, this.x, this.y, this.x + this.w, this.y + this.h);
            tCtx.stroke();
        }

        if (showUI) {
            tCtx.setLineDash([5, 5]);
            tCtx.strokeStyle = "#007bff";
            tCtx.lineWidth = 1;
            tCtx.strokeRect(this.x - 4, this.y - 4, this.w + 8, this.h + 8);
            tCtx.setLineDash([]);
            tCtx.fillStyle = "#007bff";
            tCtx.fillRect(this.x + this.w, this.y + this.h, 10, 10); // Scale handle
        }
        tCtx.restore();
    }
}

function drawArrowHead(tCtx, x1, y1, x2, y2) {
    const headlen = 15; const angle = Math.atan2(y2 - y1, x2 - x1);
    tCtx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
    tCtx.moveTo(x2, y2);
    tCtx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
}

// Interactions
canvas.addEventListener("pointerdown", e => {
    const x = e.offsetX, y = e.offsetY;

    if (activeObj) {
        // Check scale handle
        if (x > activeObj.x + activeObj.w && x < activeObj.x + activeObj.w + 20 &&
            y > activeObj.y + activeObj.h && y < activeObj.y + activeObj.h + 20) {
            transformMode = "scale"; return;
        }
        // Check move
        if (x > activeObj.x && x < activeObj.x + activeObj.w && y > activeObj.y && y < activeObj.y + activeObj.h) {
            transformMode = "move"; lastX = x; lastY = y; return;
        }
        bake(); // Clicked away
    }

    if (tool === 'text') { 
        showTextInput(e); return; 
    }

    drawing = true;
    startX = x; startY = y;

    if (tool === 'pen' || tool === 'eraser') {
        ctx.beginPath(); ctx.moveTo(x, y);
    } else if (shapeSelect.value !== 'none') {
        activeObj = new CanvasObject(shapeSelect.value, x, y, colorPicker.value, parseInt(sizePicker.value));
    }
});

canvas.addEventListener("pointermove", e => {
    const x = e.offsetX, y = e.offsetY;

    if (transformMode && activeObj) {
        if (transformMode === "scale") {
            activeObj.w = x - activeObj.x; activeObj.h = y - activeObj.y;
        } else {
            activeObj.x += (x - lastX); activeObj.y += (y - lastY);
            lastX = x; lastY = y;
        }
        render(); return;
    }

    if (!drawing) return;

    if (tool === 'pen' || tool === 'eraser') {
        ctx.lineWidth = sizePicker.value;
        ctx.lineCap = "round";
        ctx.strokeStyle = (tool === 'eraser') ? "white" : colorPicker.value;
        if (tool === 'eraser') {
            // Manual erase to background color instead of destination-out to prevent transparency issues in PDF
            ctx.strokeStyle = "white"; 
        }
        ctx.lineTo(x, y); ctx.stroke();
    } else if (activeObj) {
        activeObj.w = x - startX; activeObj.h = y - startY;
        render();
    }
});

canvas.addEventListener("pointerup", () => {
    drawing = false; transformMode = null;
    if (tool === 'pen' || tool === 'eraser') saveToBackground();
    render();
});

// Tool logic
document.querySelectorAll("#toolbar button").forEach(btn => {
    btn.onclick = () => {
        if (btn.id === 'clearBtn') { ctx.clearRect(0,0,canvas.width,canvas.height); saveToBackground(); render(); return; }
        if (btn.id === 'exportBtn') { bake(); window.print(); return; }
        bake();
        tool = btn.id.replace("Btn", "");
        document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        shapeSelect.value = "none";
    };
});

shapeSelect.onchange = () => { if (shapeSelect.value !== "none") { bake(); tool = "shape"; } };

function showTextInput(e) {
    const fontSize = parseInt(sizePicker.value) + 15;
    textInput.style.display = "block";
    textInput.style.left = e.pageX + "px"; textInput.style.top = (e.pageY - fontSize/2) + "px";
    textInput.style.fontSize = fontSize + "px";
    startX = e.offsetX; startY = e.offsetY;
    setTimeout(() => textInput.focus(), 10);
}

textInput.onblur = () => {
    if (textInput.value.trim() !== "") {
        activeObj = new CanvasObject('text', startX, startY, colorPicker.value, parseInt(sizePicker.value), textInput.value);
        render();
    }
    textInput.style.display = "none"; textInput.value = "";
};

document.addEventListener("keydown", e => {
    if (e.key === "Delete" && activeObj) { activeObj = null; render(); }
    if (e.key === "Enter" && textInput.style.display === "block") textInput.blur();
});
</script>
</body>
</html>
