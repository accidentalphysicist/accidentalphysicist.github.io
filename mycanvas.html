<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>v2Teaching Canvas - Pro Stylus + Paste</title>
<style>
  body { margin: 0; background: #1e1e1e; font-family: sans-serif; color: white; }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0;
    background: #2b2b2b; padding: 8px; display: flex; gap: 8px; z-index: 100;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5); align-items: center; flex-wrap: wrap;
  }
  @media print {
    #toolbar, #textInput { display: none !important; }
    body { background: white; }
    #canvas-container { margin: 0; height: auto; }
    canvas { box-shadow: none; margin: 0; border: none; }
  }
  button, input { padding: 6px 12px; cursor: pointer; border: none; border-radius: 4px; background: #444; color: white; font-weight: bold; }
  button.active { background: #007bff; outline: 2px solid yellow; }
  #canvas-container { margin-top: 80px; padding-bottom: 50px; background: #333; min-height: 100vh; }
  canvas { background: white; display: block; margin: 0 auto; cursor: crosshair; touch-action: none; }
  #textInput { position: absolute; display: none; background: white; border: 1px solid #007bff; color: black; outline: none; z-index: 1000; }
</style>
</head>
<body>

<div id="toolbar">
  <button id="penBtn" class="active">Pen</button>
  <button id="eraserBtn">Eraser</button>
  <button id="lineBtn">Line</button>
  <button id="rectBtn">Rect</button>
  <button id="circleBtn">Circle</button>
  <button id="textBtn">Text</button>
  <button id="selectBtn">Select</button>
  <div style="width:1px; height:25px; background:#555;"></div>
  <input type="color" id="colorPicker" value="#000000">
  <input type="range" id="sizePicker" min="1" max="50" value="3">
  <button id="extendBtn">+ Extend</button>
  <button id="exportBtn" style="background: #28a745;">Export PDF</button>
  <button id="clearBtn" style="background:#8b0000;">Clear</button>
</div>

<div id="canvas-container">
  <canvas id="canvas" width="1200" height="1500"></canvas>
  <input type="text" id="textInput">
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });
const colorPicker = document.getElementById("colorPicker");
const sizePicker = document.getElementById("sizePicker");
const textInput = document.getElementById("textInput");

let tool = "pen";
let drawing = false;
let isMovingSelection = false;
let startX, startY, lastX, lastY;
let snapshot, selectionData, selectionRect = null;
const undoStack = [];

function saveState() {
  if (undoStack.length >= 30) undoStack.shift();
  undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
}

function undo() {
  if (undoStack.length > 1) {
    undoStack.pop();
    ctx.putImageData(undoStack[undoStack.length - 1], 0, 0);
    selectionRect = null; 
  }
}

saveState();

// Tool Selection
document.querySelectorAll("#toolbar button").forEach(btn => {
  btn.onclick = () => {
    if(btn.id === "clearBtn" && confirm("Clear Canvas?")) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        saveState(); return;
    }
    if(btn.id === "extendBtn") {
        const temp = ctx.getImageData(0, 0, canvas.width, canvas.height);
        canvas.height += 1000;
        ctx.putImageData(temp, 0, 0);
        saveState();
        return;
    }
    if(btn.id === "exportBtn") { window.print(); return; }

    // Finalize selection if switching tools
    if (selectionRect) finalizeSelection();

    tool = btn.id.replace("Btn", "");
    document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    textInput.style.display = "none";
  };
});

function finalizeSelection() {
    if (!selectionRect) return;
    ctx.putImageData(selectionData, selectionRect.x, selectionRect.y);
    selectionRect = null;
    saveState();
}

canvas.addEventListener("pointerdown", e => {
  const x = e.offsetX;
  const y = e.offsetY;

  if (tool === "select" && selectionRect && 
      x >= selectionRect.x && x <= selectionRect.x + selectionRect.w &&
      y >= selectionRect.y && y <= selectionRect.y + selectionRect.h) {
    isMovingSelection = true;
    lastX = x;
    lastY = y;
    return;
  }

  // Click away from selection to bake it
  if (selectionRect && tool === "select") {
      finalizeSelection();
  }

  if (tool === "text") {
    showTextInput(e);
    return;
  }

  drawing = true;
  startX = x; startY = y;
  lastX = x; lastY = y;
  snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  ctx.strokeStyle = colorPicker.value;
  ctx.lineWidth = sizePicker.value;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  
  if (tool === 'pen' || tool === 'eraser') {
    ctx.beginPath();
    ctx.moveTo(x, y);
  }
});

canvas.addEventListener("pointermove", e => {
  const x = e.offsetX;
  const y = e.offsetY;

  if (isMovingSelection) {
    ctx.putImageData(snapshot, 0, 0);
    selectionRect.x += (x - lastX);
    selectionRect.y += (y - lastY);
    ctx.putImageData(selectionData, selectionRect.x, selectionRect.y);
    drawSelectionDashes(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
    lastX = x; lastY = y;
    return;
  }

  if (!drawing) return;

  if (tool === "pen") {
    ctx.lineTo(x, y); ctx.stroke();
  } else if (tool === "eraser") {
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineTo(x, y); ctx.stroke();
    ctx.globalCompositeOperation = "source-over";
  } else {
    ctx.putImageData(snapshot, 0, 0);
    if (tool === "line") {
      ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(x, y); ctx.stroke();
    } else if (tool === "rect") {
      ctx.strokeRect(startX, startY, x - startX, y - startY);
    } else if (tool === "circle") {
      ctx.beginPath(); ctx.arc(startX, startY, Math.hypot(x-startX, y-startY), 0, Math.PI*2); ctx.stroke();
    } else if (tool === "select") {
      drawSelectionDashes(startX, startY, x - startX, y - startY);
    }
  }
});

canvas.addEventListener("pointerup", e => {
  if (tool === "select" && drawing) {
    const w = e.offsetX - startX;
    const h = e.offsetY - startY;
    if (Math.abs(w) > 5 && Math.abs(h) > 5) {
      selectionRect = { x: startX, y: startY, w, h };
      selectionData = ctx.getImageData(startX, startY, w, h);
      ctx.clearRect(startX, startY, w, h);
      snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.putImageData(selectionData, startX, startY);
      drawSelectionDashes(startX, startY, w, h);
    }
  }
  if (drawing || isMovingSelection) {
    drawing = false;
    isMovingSelection = false;
    saveState();
  }
});

/* =========================
   CLIPBOARD (PASTE) SUPPORT
========================= */
window.addEventListener('paste', e => {
  const items = e.clipboardData.items;
  for (let item of items) {
    if (item.type.indexOf("image") !== -1) {
      const blob = item.getAsFile();
      const img = new Image();
      img.onload = () => {
        // Place image and automatically select it
        ctx.drawImage(img, 20, 20);
        selectionRect = { x: 20, y: 20, w: img.width, h: img.height };
        selectionData = ctx.getImageData(20, 20, img.width, img.height);
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height); // snapshot without the image for moving
        drawSelectionDashes(20, 20, img.width, img.height);
        saveState();
      };
      img.src = URL.createObjectURL(blob);
    } else if (item.type === "text/plain") {
        item.getAsString(text => {
            textInput.value = text;
            showTextInput({ pageX: 100, pageY: 100, offsetX: 100, offsetY: 100 });
        });
    }
  }
});

function drawSelectionDashes(x, y, w, h) {
  ctx.setLineDash([5, 5]);
  ctx.strokeStyle = "#007bff";
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);
  ctx.setLineDash([]);
}

function showTextInput(e) {
  const fontSize = parseInt(sizePicker.value) + 15;
  textInput.style.display = "block";
  textInput.style.left = e.pageX + "px";
  textInput.style.top = (e.pageY - fontSize/2) + "px";
  textInput.style.fontSize = fontSize + "px";
  textInput.style.color = colorPicker.value;
  startX = e.offsetX; startY = e.offsetY;
  setTimeout(() => textInput.focus(), 10);
}

textInput.onkeydown = e => {
  if (e.key === "Enter") {
    ctx.fillStyle = colorPicker.value;
    ctx.font = `${parseInt(sizePicker.value) + 15}px sans-serif`;
    ctx.textBaseline = "middle";
    ctx.fillText(textInput.value, startX, startY);
    textInput.style.display = "none";
    saveState();
  }
};

document.addEventListener("keydown", e => {
  if (e.key === "Delete" && selectionRect) {
    ctx.putImageData(snapshot, 0, 0); 
    selectionRect = null;
    saveState();
  }
  if (e.ctrlKey && e.key === "z") { e.preventDefault(); undo(); }
});
</script>
</body>
</html>
