<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Teaching Canvas</title>

<style>
  body {
    margin: 0;
    background: #1e1e1e;
    font-family: sans-serif;
    color: white;
  }

  #toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #2b2b2b;
    padding: 8px;
    display: flex;
    gap: 8px;
    z-index: 10;
  }

  button, input {
    padding: 6px;
    cursor: pointer;
  }

  button.active {
    outline: 2px solid yellow;
  }

  #canvas-container {
    margin-top: 60px;
    height: calc(100vh - 60px);
    overflow-y: scroll;
  }

  canvas {
    background: white;
    display: block;
    margin: auto;
  }

  textarea {
    resize: none;
    outline: none;
  }
</style>
</head>

<body>

<div id="toolbar">
  <button id="penBtn" class="active">Pen</button>
  <button id="eraserBtn">Eraser</button>
  <button id="lineBtn">Line</button>
  <button id="rectBtn">Rect</button>
  <button id="circleBtn">Circle</button>

  <input type="color" id="colorPicker" value="#000000">
  <input type="range" id="sizePicker" min="1" max="12" value="3">

  <button id="exportBtn">Export PDF</button>
</div>

<div id="canvas-container">
  <canvas id="canvas" width="1200" height="10000"></canvas>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
/* =========================
   BASIC SETUP
========================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

ctx.lineCap = "round";
ctx.lineJoin = "round";

let tool = "pen";
let drawing = false;
let startX, startY;
let lastX = 0, lastY = 0;
let pointerType = "mouse";

/* =========================
   UNDO / REDO
========================= */
const undoStack = [];
const redoStack = [];
const MAX_HISTORY = 50;

function saveState() {
  if (undoStack.length >= MAX_HISTORY) undoStack.shift();
  undoStack.push(canvas.toDataURL());
  redoStack.length = 0;
}

function restore(from, to) {
  if (!from.length) return;
  to.push(canvas.toDataURL());

  const img = new Image();
  img.src = from.pop();
  img.onload = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);
  };
}

document.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") {
    e.preventDefault();
    restore(undoStack, redoStack);
  }
  if (e.ctrlKey && e.key === "y") {
    e.preventDefault();
    restore(redoStack, undoStack);
  }
});

saveState(); // initial blank state

/* =========================
   TOOL SELECTION
========================= */
function setTool(name, btn) {
  tool = name;
  document.querySelectorAll("button").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");
}

penBtn.onclick = () => setTool("pen", penBtn);
eraserBtn.onclick = () => setTool("eraser", eraserBtn);
lineBtn.onclick = () => setTool("line", lineBtn);
rectBtn.onclick = () => setTool("rect", rectBtn);
circleBtn.onclick = () => setTool("circle", circleBtn);

/* =========================
   POINTER EVENTS (Stylus Friendly)
========================= */
canvas.addEventListener("pointerdown", e => {
  drawing = true;
  pointerType = e.pointerType;
  startX = lastX = e.offsetX;
  startY = lastY = e.offsetY;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
});

canvas.addEventListener("pointermove", e => {
  if (!drawing) return;

  const pressure = e.pressure || 0.5;
  const baseSize = sizePicker.value;
  ctx.lineWidth = baseSize * (pointerType === "pen" ? pressure * 2 : 1);

  if (tool === "pen") {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = colorPicker.value;
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
  }

  if (tool === "eraser") {
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
  }

  lastX = e.offsetX;
  lastY = e.offsetY;
});

canvas.addEventListener("pointerup", e => {
  if (!drawing) return;
  drawing = false;
  ctx.globalCompositeOperation = "source-over";

  const endX = e.offsetX;
  const endY = e.offsetY;

  if (tool === "line") {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }

  if (tool === "rect") {
    ctx.strokeRect(startX, startY, endX - startX, endY - startY);
  }

  if (tool === "circle") {
    const r = Math.hypot(endX - startX, endY - startY);
    ctx.beginPath();
    ctx.arc(startX, startY, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  saveState();
});

/* =========================
   TEXT INPUT (Keyboard)
========================= */
canvas.addEventListener("dblclick", e => {
  createTextInput(e.offsetX, e.offsetY);
});

function createTextInput(x, y, preset = "") {
  const ta = document.createElement("textarea");
  ta.value = preset;
  ta.style.position = "absolute";
  ta.style.left = canvas.offsetLeft + x + "px";
  ta.style.top = canvas.offsetTop + y + "px";
  ta.style.font = "18px sans-serif";
  ta.style.border = "1px dashed gray";

  document.body.appendChild(ta);
  ta.focus();

  ta.onblur = () => {
    drawText(ta.value, x, y);
    ta.remove();
    saveState();
  };
}

function drawText(text, x, y) {
  ctx.fillStyle = colorPicker.value;
  ctx.font = "18px sans-serif";
  text.split("\n").forEach((line, i) => {
    ctx.fillText(line, x, y + i * 22);
  });
}

/* =========================
   COPY / PASTE SUPPORT
========================= */
document.addEventListener("paste", e => {
  const text = e.clipboardData.getData("text");
  if (!text) return;
  drawText(text, lastX || 50, lastY || 50);
  saveState();
});

/* =========================
   EXPORT TO PDF
========================= */
exportBtn.onclick = () => {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF("p", "px", "a4");

  const img = canvas.toDataURL("image/png");
  const imgHeight = canvas.height * 595 / canvas.width;
  let y = 0;

  while (y < imgHeight) {
    pdf.addImage(img, "PNG", 0, -y, 595, imgHeight);
    y += pdf.internal.pageSize.height;
    if (y < imgHeight) pdf.addPage();
  }

  pdf.save("class-notes.pdf");
};
</script>

</body>
</html>
